"""
Company DNA Service — The Institutional Memory
Auto-generates and maintains a Company DNA Markdown document per startup.
All agents read this on every heartbeat to stay aligned.
OpenClaw-inspired: like HEARTBEAT.md but at the organizational level.
"""

import json
import structlog
from datetime import datetime, timezone
from typing import Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.startup import Startup
from app.models.agent_memory import AgentMemoryEntry

logger = structlog.get_logger()


class CompanyDNAService:
    """
    Generates and caches a 'Company DNA' document for each startup.
    This is the single source of truth that every agent reads.
    """

    def _generate_dna_markdown(self, startup: Startup, memories: list[AgentMemoryEntry]) -> str:
        """Generate the Company DNA document as Markdown."""
        metrics = startup.metrics or {}
        stage = startup.stage.value if hasattr(startup, "stage") else "unknown"

        # Group memories by type
        strategies = [m for m in memories if m.memory_type.value == "strategy"]
        learnings = [m for m in memories if m.memory_type.value == "learning"]
        warnings = [m for m in memories if m.memory_type.value == "warning"]
        preferences = [m for m in memories if m.memory_type.value == "preference"]

        now = datetime.now(timezone.utc).isoformat()

        dna = f"""# Company DNA — {startup.name}
# Auto-Generated by MomentAIc Autonomous Systems
# Last Updated: {now}

## Company Info
- **Name:** {startup.name}
- **Stage:** {stage}
- **Industry:** {getattr(startup, 'industry', 'Not specified')}

## Current Metrics
"""
        if metrics:
            for key, value in metrics.items():
                dna += f"- **{key}:** {value}\n"
        else:
            dna += "- No metrics recorded yet\n"

        dna += "\n## Active Strategies\n"
        if strategies:
            for s in strategies[:5]:
                dna += f"- {s.value}\n"
        else:
            dna += "- No active strategies defined\n"

        dna += "\n## Key Learnings\n"
        if learnings:
            for l in learnings[:5]:
                dna += f"- {l.value}\n"
        else:
            dna += "- No learnings recorded yet\n"

        dna += "\n## Active Warnings\n"
        if warnings:
            for w in warnings[:3]:
                dna += f"- ⚠️ {w.value}\n"
        else:
            dna += "- No active warnings\n"

        dna += "\n## Founder Preferences\n"
        if preferences:
            for p in preferences[:5]:
                dna += f"- {p.key}: {p.value}\n"
        else:
            dna += "- No preferences recorded yet\n"

        return dna

    async def get_dna(self, db: AsyncSession, startup_id: str) -> Optional[str]:
        """Get or generate the Company DNA document for a startup."""
        try:
            from uuid import UUID
            sid = UUID(startup_id)

            # Fetch startup
            result = await db.execute(select(Startup).where(Startup.id == sid))
            startup = result.scalar_one_or_none()
            if not startup:
                return None

            # Fetch relevant memories (global scope)
            mem_result = await db.execute(
                select(AgentMemoryEntry)
                .where(
                    AgentMemoryEntry.startup_id == sid,
                    AgentMemoryEntry.agent_name == "*",  # Global memories
                )
                .order_by(AgentMemoryEntry.importance.desc())
                .limit(20)
            )
            memories = list(mem_result.scalars().all())

            return self._generate_dna_markdown(startup, memories)

        except Exception as e:
            logger.error("Failed to generate Company DNA", startup_id=startup_id, error=str(e))
            return None

    async def update_dna_entry(
        self,
        db: AsyncSession,
        startup_id: str,
        key: str,
        value: str,
        memory_type: str = "strategy",
        importance: int = 7,
    ) -> None:
        """Write a new entry to the Company DNA (persisted in agent memory)."""
        from uuid import UUID
        from app.models.agent_memory import MemoryType

        try:
            mem_type = MemoryType(memory_type)
        except ValueError:
            mem_type = MemoryType.fact

        entry = AgentMemoryEntry(
            startup_id=UUID(startup_id),
            agent_name="*",  # Global scope — all agents can read
            memory_type=mem_type,
            key=key,
            value=value,
            importance=importance,
        )
        db.add(entry)
        await db.flush()

        logger.info("Company DNA updated", startup_id=startup_id, key=key)
